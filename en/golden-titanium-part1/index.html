<!doctype html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>Roberto Cano Blog</title>
<meta name="description" content="Losing my virginity

">
<meta name="keywords" content="Programming">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Roberto Cano Blog">
<meta name="twitter:description" content="Losing my virginity

">
<meta name="twitter:site" content="@robersoca">
<meta name="twitter:creator" content="@robersoca">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://www.robertocano.es/images/Codility.jpg">

<!-- Open Graph -->
<meta property="og:locale" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="Roberto Cano Blog">
<meta property="og:description" content="Losing my virginity

">
<meta property="og:url" content="http://www.robertocano.es/en/golden-titanium-part1/">
<meta property="og:site_name" content="Roberto Cano Blog">






<link rel="canonical" href="http://www.robertocano.es/en/golden-titanium-part1/">
<link href="http://www.robertocano.es/feed.xml" type="application/atom+xml" rel="alternate" title="Roberto Cano Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://www.robertocano.es/assets/css/main.css">
<!-- Webfonts -->
<script src="//use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
  <script src="http://www.robertocano.es/assets/js/vendor/html5shiv.min.js"></script>
  <script src="http://www.robertocano.es/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="http://www.robertocano.es/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>

<!-- Icons -->
<link rel="shortcut icon" href="http://www.robertocano.es/favicon.ico">

</head>

<body id="post">

<div class="navigation-wrapper">
	<nav role="navigation" id="site-nav" class="animated drop">
	    <ul>
      	  
		    
		    <li><a href="http://www.robertocano.es/" >Blog</a></li>
		  
		    
		    <li><a href="http://www.robertocano.es/about/" >About</a></li>
		  
		    
		    <li><a href="http://www.robertocano.es/search/" >Search</a></li>
		  
	    </ul>
	</nav>
</div><!-- /.navigation-wrapper -->


<div id="main" role="main">
 	<article class="hentry">

		<!-- Heading section of the web including the page featured image
     and in case of the main page, the logo, title and description -->

<!-- Featured image -->

<div class="entry-feature-header">
	<img src="http://www.robertocano.es/images/Codility.jpg" class="entry-feature-image animated fadeIn" alt="">
	

	
</div>


	
		<div class="entry-wrapper">
			<!-- Page title for main page and posts -->

<header class="entry-header">
	<h1 class="entry-title">
		
			Golden titanium alchemy - Algorithm (1/2)
		
	</h1>
</header>


			<!-- Post information -->
			<footer class="entry-meta">
				<!-- Avatar -->
				<img src="http://www.robertocano.es/images/bio-photo.jpg" class="bio-photo" alt="Roberto Cano bio photo"></a>

				<!-- Author name -->
				<span class="author vcard">
					by
					<span class="fn">
						Roberto Cano
					</span>
				</span>

				<!-- Publish date -->
				<span class="entry-date date published">
					<time datetime="2016-09-08T00:00:00+02:00">
						<i class="fa fa-calendar-o"></i>
						
						september
						 08, 2016
					</time>
				</span>

				<!-- Modified date -->
				

				<!-- Comments section -->
				
					<span class="entry-comments">
						<i class="fa fa-comment-o"></i>
						<a href="#disqus_thread">Comment</a>
					</span>
				

				<!-- Social sharing -->
				<span class="social-share-twitter">
  <a href="https://twitter.com/intent/tweet?hashtags=Programming&amp;text=&amp;url=http://www.robertocano.es/en/golden-titanium-part1/&amp;via=robersoca" title="Share on Twitter" itemprop="Twitter"><i class="fa fa-twitter-square"></i> Tweet</a>
</span>
<span class="social-share-facebook">
  <a href="https://www.facebook.com/sharer/sharer.php?u=http://www.robertocano.es/en/golden-titanium-part1/" title="Share on Facebook" itemprop="Facebook"><i class="fa fa-facebook-square"></i> Like</a>
</span>
<span class="social-share-googleplus">
  <a href="https://plus.google.com/share?url=http://www.robertocano.es/en/golden-titanium-part1/" title="Share on Google Plus" itemprop="GooglePlus"><i class="fa fa-google-plus-square"></i> +1</a>
</span>
<!-- /.social-share -->

			</footer>

			<!-- Post content -->
			<div class="entry-content">
				<h1 id="losing-my-virginity">Losing my virginity</h1>

<p>Yeah, you are in the right blog, don’t worry. I just happen to have a rather quirky sense
of humor. I’m gonna tell you the story of how I lost my virginity and won a golden award.
Oh yeah!</p>

<p>Recently I was sailing the internet stopping at islands of unspeakable names, when I ran
aground on the most peculiar island I had ever seen on my numerous sea adventures: <a href="http://www.codility.com">Codility</a>.
A seemingly paradisiacal oasis for programmers that challenged my senses and my understanding
of fun and logic.</p>

<p>While romping at this site like a burglar in an abandoned gold mine, I saw it:</p>

<p style="font-size: 200%;"><strong>~~THE CHALLENGE~~</strong></p>

<p>Well, the upper case letters were not there, buts its Unicode lower case counterparts were. A new challenge
had started just few hours before, and it went by the name of Titanium<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>There were other tests, yes, but they belonged to the past, their petty trials paled in comparison
with this new behemoth that questioned the very nature of the human mind<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.</p>

<p>And I was the chosen one, erected to tackle the Titanium Challenge!</p>

<h1 id="baby-steps">Baby steps</h1>

<p>So what was all this fuzz about?</p>

<p><a href="https://codility.com/programmers/task/brackets_rotation/">THIS</a>.</p>

<p>Basically the aforementioned challenge consisted on writing a
program to solve a problem. The language of choice could be one of many options available,
including C and C++, which I’m proficient in.</p>

<p>The problem? Parent matching.</p>

<blockquote>
  <p>Parent matching?</p>
</blockquote>

<p>Well, sorry, parenthesis matching. I was just trying to shorten the story<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. The problem consisted
on matching a sequence of parenthesis given as an input, along a maximum number of swaps that could be
performed on the input string. The swaps could be used to maximize the matchings. The implemented
function should return correctly the maximum number of matched parenthesis that the algorithm could
achieve by using the given number of swaps. It is important to note that the function should return
the maximum number of matched parenthesis, and not matched pairs (which in the end turns to be the
number of pairs multiplied by 2).</p>

<blockquote>
  <p>How could you tackle such an overly complicated task?</p>
</blockquote>

<p>Good question! Rather easily. At least the first part, the parenthesis matching. It turns out that apart
from a correct output, the function must also comply with space and time complexity constraints (big-O
notation). Both were bound by O(N), meaning it should run on linear time<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> and use an amount of
memory linearly proportional to the number of input parenthesis.</p>

<p>So let’s tackle the first part first. But before, a big disclaimer from our sponsors:</p>

<hr />
<p style="font-size: 120%;"><strong>I have NOT, listen carefully, NOT tested the snippets of code provided here. The only snippet
that works is the last one of the part 2 of this article, which is the one presented
for Codility. The rest are coming from the top of my head, like little lice jumping out
of me. I tried to be as close to bug free as possible, but you may need to fix something
there. So no complaints!</strong></p>
<hr />

<h1 id="parenthesis-matching-or-how-much-did-i-miss-my-stack">Parenthesis matching or how much did I miss my stack</h1>

<p>How do you match parenthesis that must be nested? The answer is a stack. I hope you are familiar with
what a stack is, otherwise the rest of this article may melt your brain a bit. With a simple loop
and a stack from the C++ STL we can determine whether the input parenthesis are matched or not:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isMatched</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>That is great!</p>
</blockquote>

<p>Well, yes, but not too useful. From the zillion combinations we may receive as an input only
a few will be well formed nested parenthesis expressions, but this function may be useful for
something else. What if we mark which parenthesis have matches? For that we will need to remember
the position of the opening parenthesis, so we can mark that position also as matched, so we will
use 2 stacks, one for matching the parenthesis, and the other one to save the positions:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">markedMatched</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">intr</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">pos</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span>
            <span class="n">S</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span>

            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">pos</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>At the end of the function the string S will contain ‘X’ symbols in all positions with matched
parenthesis. So far so good! With this we can now actually count the number of ‘X’ in S and
we have a lower bound for the maximum number of matching parenthesis we can achieve<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>.</p>

<h1 id="throw-it-all-out-the-window">Throw it all out the window!</h1>

<p>This is great, but we are still not fixing the string to maximize the number of matches. How
to do that? Well this paragraph will propose the culprit of the whole algorithm, so if you
want to try by yourself, stop reading NOW!</p>

<blockquote>
  <p>Now?</p>
</blockquote>

<p><strong>NOW!! Flee, you fools!</strong></p>

<blockquote>
  <p>But now, now?</p>
</blockquote>

<p>Oh, jeez, yeah.</p>

<p style="font-size: 120%;"><strong>SPOILER ALERT!!!</strong></p>

<p>The answer is: sliding window!</p>

<p>This is how this works: because the matching parenthesis
must form a valid parenthesis sequence, and a valid sequence is defined as:</p>

<ul>
  <li>It is empty</li>
  <li>It has the form “(U)” where U is a valid bracket sequence</li>
  <li>It has the form “VW” where V and W are valid bracket sequences</li>
</ul>

<p>Any valid sequence will have a consecutive number of matching parenthesis.</p>

<blockquote>
  <p>?????</p>
</blockquote>

<p>Look at it this way: if you have a long parenthesis sequence and you introduce a single
unmatched parenthesis in the middle of the sequence you are splitting the sequence in 2.
Flipping any of the parenthesis in the original sequence to match the new parenthesis
will unmatch another parenthesis (because they come in pairs).</p>

<p>Now we have blocks of matched parenthesis followed by one or more unmatched parenthesis.
Every 2 consecutive unmatched parenthesis can be matched by flipping one or two of them,
depending on the unmatched configuration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>)) --&gt; 1 flip  --&gt; ()
(( --&gt; 1 flip  --&gt; ()
)( --&gt; 2 flips --&gt; ()
</code></pre></div></div>

<p>For the first 2 cases a single flip will do, while for the third case you need 2 flips.
Any parenthesis right after or right before a matched block can be matched either with a
consecutive unmatched parenthesis or with a parenthesis at the other side of the matched
block. In the end the idea is to find a sequence of matched blocks divided by unmatched
blocks that we can fix with the limited number of flips we are given and get the longest
sequence of matched parenthesis.</p>

<p>The only caveat with this problem is that it is not a local one. The main reason is that
local information surrounding a matched or unmatched block does not give us all the information
we need to know if the block should be part of the final solution or not.</p>

<p>Due to this we need to analyse the whole string to understand which blocks are going to be
part of the longest streak of matched parenthesis. However one thing is true: the streak
must be consecutive, as this is one of the premises of the problem.</p>

<p>Thus, the solution is a sliding window. We’ll start analysing from the first symbol in the
string and then see how many consecutive symbols we can get by flipping the unmatched blocks,
and we will save that number. Then we will start from the second symbols, and do the same
operation, saving the number. Then the third and so on, until we actually have the maximum
number of consecutive symbols achievable with the limited number of flips we have.</p>

<p>Easy, right?</p>

<p>Remember the next function gets called after ‘markedMatched’ and S will contain ‘X’ symbols
where matched parenthesis are found.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findLongestStreak</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxFlips</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxStreak</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Per problem requirements, return -1 if no
                           possible solution is found */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">edits</span> <span class="o">=</span> <span class="n">maxFlips</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">prevSymbol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">S</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Matched block */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">streak</span><span class="o">++</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Found an unmatched parenthesis but
               we are out of edits, end the loop */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Same parenthesis symbol twice means we only
               need one edit to transform it into a matched
               parenthesis:

               )) -&gt; ()
               (( -&gt; ()

               Remember it does not matter if the parenthesis
               is consecutive or there is a matched block in
               between
            */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prevSymbol</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">edits</span><span class="o">--</span><span class="p">;</span>
                <span class="n">streak</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">prevSymbol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Special case, will only happen once in the whole
               loop, when the unmatched parenthesis change from ')'
               to '('. In this case we need 2 edits to match them,
               so we can only do it if we have 2 edits left */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prevSymbol</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">edits</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">edits</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">streak</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">prevSymbol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Rest of cases, no edit needed */</span>
            <span class="n">prevSymbol</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">&gt;</span> <span class="n">maxStreak</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">maxStreak</span> <span class="o">=</span> <span class="n">streak</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxStreak</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And <em>et voilà</em>, that will return the correct solution! Easy-peasy! Peanuts!</p>

<blockquote>
  <p>Wow!</p>
</blockquote>

<p>Yeah! Wow! So you were wondering, did this awarded me my golden Codility award….no way!</p>

<blockquote>
  <p>Why?</p>
</blockquote>

<p>Well, problem were cycles! Not like the cycles problem found in graph algorithms. But rather
CPU cycles. My program was too slow for Codility to award me a golden thingy. Dear reader,
come with me for the final journey into the realm of the pure fast. Let’s optimize this shit
together!</p>

<p>For that you’ll need to read the continuation in a follow-up article!</p>

<blockquote>
  <p>Cliffhanger!</p>
</blockquote>

<p><strong>Cliffhanger!</strong></p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Is it only me or the this 2 syllables ‘tit’ and ‘anium’ sound rather funny? <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Yeah, well, actually there are other challenges in Codility that are REALLY crazy, but I have to sell it, right? <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Yeah, sure! <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>If you are not familiar you can check one of many articles explaining it, like this one: http://web.mit.edu/16.070/www/lecture/big_o.pdf <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>If you get less than that number, you are doing something really wrong! <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


				<!-- Show comments -->
				
					<div id="disqus_thread"></div><!-- /#disqus_thread -->
					
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'robertocano'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

				
		  	</div><!-- /.entry-content -->
		</div><!-- /.entry-wrapper -->

		<!-- Pagination -->
    	<nav class="pagination" role="navigation">
      		
        		<a href="http://www.robertocano.es/en/compiling-a-crosscompiler/" class="btn" title="How to compile a cross-compiler">Previous</a>
      		
      		
        		<a href="http://www.robertocano.es/en/golden-titanium-part2/" class="btn" title="Golden titanium alchemy - Optimization (2/2)">Next</a>
      		
    	</nav><!-- /.pagination -->
	</article>
</div><!-- /#main -->

<!-- Page footer -->
<div class="footer-wrapper">
	<footer role="contentinfo" class="entry-wrapper">
		<span>
			&copy; 2021 Roberto Cano. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/so-simple/" rel="nofollow">So Simple Theme</a>.
		</span>
		<div class="social-icons">
			
				<a href="http://twitter.com/robersoca" title="Roberto Cano on Twitter" target="_blank"><i class="fa fa-twitter-square fa-2x"></i></a>
			
			
			
			
				<a href="http://linkedin.com/in/robertocano" title="Roberto Cano on LinkedIn" target="_blank"><i class="fa fa-linkedin-square fa-2x"></i></a>
			
			
			
			
			
				<a href="http://github.com/robercano" title="Roberto Cano on Github" target="_blank"><i class="fa fa-github-square fa-2x"></i></a>
			
			
			
			<a href="http://www.robertocano.es/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss-square fa-2x"></i></a>
		</div><!-- /.social-icons -->
	</footer>
</div><!-- /.footer-wrapper -->

<script type="text/javascript">
  var BASE_URL = 'http://www.robertocano.es';
</script>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://www.robertocano.es/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://www.robertocano.es/assets/js/scripts.min.js"></script>




</body>
</html>
