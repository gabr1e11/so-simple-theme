<!doctype html>
<html class="no-js" lang="en">
<head>
<meta charset="utf-8">
<title>Roberto Cano Blog</title>
<meta name="description" content="De-introduction

">
<meta name="keywords" content="Programming">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Roberto Cano Blog">
<meta name="twitter:description" content="De-introduction

">
<meta name="twitter:site" content="@robersoca">
<meta name="twitter:creator" content="@robersoca">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://www.robertocano.es/images/Codility.jpg">

<!-- Open Graph -->
<meta property="og:locale" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="Roberto Cano Blog">
<meta property="og:description" content="De-introduction

">
<meta property="og:url" content="http://www.robertocano.es/en/golden-titanium-part2/">
<meta property="og:site_name" content="Roberto Cano Blog">






<link rel="canonical" href="http://www.robertocano.es/en/golden-titanium-part2/">
<link href="http://www.robertocano.es/feed.xml" type="application/atom+xml" rel="alternate" title="Roberto Cano Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://www.robertocano.es/assets/css/main.css">
<!-- Webfonts -->
<script src="//use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
  <script src="http://www.robertocano.es/assets/js/vendor/html5shiv.min.js"></script>
  <script src="http://www.robertocano.es/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="http://www.robertocano.es/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>

<!-- Icons -->
<link rel="shortcut icon" href="http://www.robertocano.es/favicon.ico">

</head>

<body id="post">

<div class="navigation-wrapper">
	<nav role="navigation" id="site-nav" class="animated drop">
	    <ul>
      	  
		    
		    <li><a href="http://www.robertocano.es/" >Blog</a></li>
		  
		    
		    <li><a href="http://www.robertocano.es/about/" >About</a></li>
		  
		    
		    <li><a href="http://www.robertocano.es/search/" >Search</a></li>
		  
	    </ul>
	</nav>
</div><!-- /.navigation-wrapper -->


<div id="main" role="main">
 	<article class="hentry">

		<!-- Heading section of the web including the page featured image
     and in case of the main page, the logo, title and description -->

<!-- Featured image -->

<div class="entry-feature-header">
	<img src="http://www.robertocano.es/images/Codility.jpg" class="entry-feature-image animated fadeIn" alt="">
	

	
</div>


	
		<div class="entry-wrapper">
			<!-- Page title for main page and posts -->

<header class="entry-header">
	<h1 class="entry-title">
		
			Golden titanium alchemy - Optimization (2/2)
		
	</h1>
</header>


			<!-- Post information -->
			<footer class="entry-meta">
				<!-- Avatar -->
				<img src="http://www.robertocano.es/images/bio-photo.jpg" class="bio-photo" alt="Roberto Cano bio photo"></a>

				<!-- Author name -->
				<span class="author vcard">
					by
					<span class="fn">
						Roberto Cano
					</span>
				</span>

				<!-- Publish date -->
				<span class="entry-date date published">
					<time datetime="2016-09-12T00:00:00+02:00">
						<i class="fa fa-calendar-o"></i>
						
						september
						 12, 2016
					</time>
				</span>

				<!-- Modified date -->
				

				<!-- Comments section -->
				
					<span class="entry-comments">
						<i class="fa fa-comment-o"></i>
						<a href="#disqus_thread">Comment</a>
					</span>
				

				<!-- Social sharing -->
				<span class="social-share-twitter">
  <a href="https://twitter.com/intent/tweet?hashtags=Programming&amp;text=&amp;url=http://www.robertocano.es/en/golden-titanium-part2/&amp;via=robersoca" title="Share on Twitter" itemprop="Twitter"><i class="fa fa-twitter-square"></i> Tweet</a>
</span>
<span class="social-share-facebook">
  <a href="https://www.facebook.com/sharer/sharer.php?u=http://www.robertocano.es/en/golden-titanium-part2/" title="Share on Facebook" itemprop="Facebook"><i class="fa fa-facebook-square"></i> Like</a>
</span>
<span class="social-share-googleplus">
  <a href="https://plus.google.com/share?url=http://www.robertocano.es/en/golden-titanium-part2/" title="Share on Google Plus" itemprop="GooglePlus"><i class="fa fa-google-plus-square"></i> +1</a>
</span>
<!-- /.social-share -->

			</footer>

			<!-- Post content -->
			<div class="entry-content">
				<h1 id="de-introduction">De-introduction</h1>

<p>This is a follow up on <a href="http://www.robertocano.es/en/golden-titanium-part1/">this previous article</a>. Go there if you haven’t yet.</p>

<h1 id="of-when-i-squeezed-the-jiffies-out-of-my-code">Of when I squeezed the jiffies out of my code…</h1>

<p>This part was the most interesting so far for me, as I had to optimize both the algorithm
itself and also the code.</p>

<blockquote>
  <p>What does that mean, dear Lord of the Pings?</p>
</blockquote>

<p>When you design an algorithm there are usually two parts: the algorithm itself and its implementation.
Typically the algorithm is measured using the big-O notation mentioned above, which binds the algorithm
to a certain order of execution, but not to a real time of execution. That can be only measured when
the code is written in certain language, compiled with certain compiler using specific optimizations
and run in a specific computer, with a particular CPU<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.Nowadays we could say that using a good compiler
and a modern CPU should yield similar results, but specifics like CPU speed, cache levels and sizes, instruction
set, etc… can have an impact on the final measured time. For example things like locality of the algorithm
can speed up things by making a good use of the cache.</p>

<p>We won’t go as far as to analyze cache usage, but I definitely had to optimize both the algorithm to
gather information that could reduce the number of iteration in successive passes, and the code to
make a more efficient use of function calls and memory accesses.</p>

<p>Here we go, you ready?</p>

<h2 id="algorithm-optimization">Algorithm optimization</h2>

<p>So this was the thing with my algorithm. On first pass I was analyzing the input string to find the
matched blocks. While doing so I was marking the matched parenthesis with a ‘X’, remember? Then on the
second pass I was basically adding up those ‘X’ together to count the number of consecutive matched
parenthesis in a block. What if instead I saved directly the amount of matched parenthesis in a block?
Then on second pass I’d have less iterations and less additions. That should improve things a little!</p>

<p>To do so I’d need an extra array to store the new values. At this point I was deeming negligible memory
writes and reads compared to the number of iterations. It seems I was right in this particular case,
and I guess in average, although I didn’t have time to perform a deep analysis on this.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">markedMatched</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* We only increase the streak when a close parenthesis is
           found in the input string, and only if it matches an opening
           parenthesis in the top of the stack */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">&amp;&amp;</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">streak</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">streak</span><span class="p">);</span>
                <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* If we had an ongoing streak, take it into account now */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">streak</span><span class="p">);</span>
        <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we have something slightly better than ‘X’ in the output stack. However it is still not too
much optimized. The problem here is that if we have a lot of consecutive ‘()’ then we will end
up with a lot of consecutive ‘-2’ on the stack. We can do better.</p>

<blockquote>
  <p>By the way, why -2?</p>
</blockquote>

<p>Well, that is called variable substitution. Because we are already using positive integers for
symbols like ‘(‘ and ‘)’, we need a different range to represent actual streaks of matched
parenthesis, and negative numbers are just perfect, as we can add them normally and we will need
just a final negation to make the result positive.</p>

<p>To try to consolidate all those long sequences of ‘-2’ and similar subgroups of matched parenthesis
we just have to realize that once we finish a subgroup, there can be only a previous subgroup that
we can add up to make a supergroup, just because of the way groups of matching parenthesis are
defined. So we just need to check once we match a group, if there was a previous group streak saved
in the stack, if so add it to the current streak and remove it from the stack:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">markedMatched</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* We only increase the streak when a close parenthesis is
           found in the input string, and only if it matches an opening
           parenthesis in the top of the stack */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">&amp;&amp;</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">streak</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="cm">/* We found a subgroup, just check if the stack has a
               streak value for us that we need to add to the current
               streak value. If that is the case, get it out of the stack
               and add it to the current streak */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">streak</span> <span class="o">+=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
                <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">streak</span><span class="p">);</span>
                <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">streak</span><span class="p">);</span>
        <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now this function will leave the ‘st’ stack with a set of unmatched parenthesis interleaved with
some negative numbers which absolute value will tell us the size of the matched parenthesis in
between. Now that we have that, we just need to move the stack to a vector and then use it to
apply the sliding window, taking into account the new information. First move the stack into
a vector:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">stackToVector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then finally apply the sliding window algorithm on this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findLongestStreak</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxFlips</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxStreak</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Per problem requirements, return -1 if no possible solution found */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">edits</span> <span class="o">=</span> <span class="n">maxFlips</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">prevSymbol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Matched block */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">streak</span> <span class="o">+=</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Found an unmatched parenthesis but
               we are out of edits, end the loop */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Same parenthesis symbol twice means we only
               need one edit to transform it into a matched
               parenthesis:

               )) -&gt; ()
               (( -&gt; ()

               Remember it does not matter if the parenthesis
               is consecutive or there is a matched block in
               between
            */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prevSymbol</span> <span class="o">==</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">edits</span><span class="o">--</span><span class="p">;</span>
                <span class="n">streak</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">prevSymbol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Special case, will only happen once in the whole
               loop, when the unmatched parenthesis change from ')'
               to '('. In this case we need 2 edits to match them,
               so we can only do it if we have 2 edits left */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prevSymbol</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">&amp;&amp;</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">edits</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">edits</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">streak</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">prevSymbol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Rest of cases, no edit needed */</span>
            <span class="n">prevSymbol</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">&gt;</span> <span class="n">maxStreak</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">maxStreak</span> <span class="o">=</span> <span class="n">streak</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxStreak</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And TA-DA! Code super optimized! Right? RIGHT?</p>

<p>The thing is: no. I mean it is more optimized, for sure, but still not passing from
Codility Silver award. What else could we do to improve this? Well, as I mentioned
previously, we’ve optimized the algorithm. Now we can optimize the code itself.</p>

<p>In order to do that I had to analyze the timing of the different part of the algorithm.
You can do that using your favourite profiles or instrumenting the code yourself. By doing
so I learned 2 things: which function of the 2 we have is impacting the performance more<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>,
and which specifics bits of code are bringing down performance.</p>

<h1 id="and-i-was-trying-to-use-c">And I was trying to use C++…</h1>

<p>Indeed I wanted to use C++ for the solution just to demonstrate my versatility in such
indomitable language. However after a bit of profiling I realized that using a custom
implemented stack, which actually can double as a vector without any overhead, improves
the performance. Implementing a stack manually is quite easy: we just need an array and
an index into the array. Even better: we can have an array and a pointer into the array.</p>

<blockquote>
  <p>Is it not the same?</p>
</blockquote>

<p>Well, by using a pointer into the array we don’t need to increment the index and then
index the array pointer to obtain the value. The pointer into the array will point
all the time into the right position. We just need to check the boundaries properly so we
don’t point beyond the array limits.</p>

<p>Oh, I almost forgot: this optimization is easy because we know the upper bound for the stack size.
Otherwise we’d need to manage reallocations of the memory, incurring in memory copies, etc. But
we are lucky and we know exactly the maximum size of the stack, which is exactly the size of the
input string.</p>

<p>Also, and just in case you are a picky programmer that checks every dot and comma in the code,
the stack implementation I will use has one extra element to the left of the first element.
This is just because in the algorithm we are looking at position ‘i-1’ for the iteration ‘i’,
so by having that extra element we don’t need to have an extra flag that will be checked at
every iteration to know if ‘i==0’, saving us some precious cycles<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>.</p>

<p>Now I will show the final algorithm, the one that won the award (almost). You’ll excuse me if
the step from the previous shown code to this one is too steep, but otherwise the article would
take ages!</p>

<p>Let’s do it!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Some defines for an easier to read implementation */</span>
<span class="cp">#define LEFT_PAREN  '('
#define RIGHT_PAREN ')'
#define MATCH_PAREN  '.'
</span>
<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="cm">/* Stack buffer for the stack data. We will point to this
       buffer with the 'st' stack pointer. Please notice
       we allocate one extra byte to use it as a default
       initial value for the algorithm, then we initialize that
       extra value to 0 which is useful for the algorithm (see below)  */</span>
    <span class="kt">int</span> <span class="n">stbuf</span><span class="p">[</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">stbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* 'st' is the pointer into the stack, instead of an index.
       This way we avoid indexing the stack pointer to get the value */</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="cm">/* The real start of the stack is 'st + 1' as the first value is
       just bogus. We will use 'st_base' to determine if the stack
       is empty */</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">st_base</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Similar optimization for the string. Not sure it improves performance
      but just for fun */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str_end</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

    <span class="cm">/* Streak counter, similar to the previous algorithm */</span>
    <span class="kt">int</span> <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* The next for loop should be familiar, it is the one used in the
       'markedMatched' function, except the loop variable and limits are
       using our new pointer based strings and stacks, and the if condition
       inside the for is reversed */</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">str</span> <span class="o">!=</span> <span class="n">str_end</span><span class="p">;</span> <span class="o">++</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Quick comment, at the beginning of the algorithm 'st' points to the
           extra value in the stack, which is initialized to 0. This way the
           if condition will be true for the first iteration, which is OK because
           we cannot have matching parenthesis with only one parenthesis */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="n">RIGHT_PAREN</span> <span class="o">||</span> <span class="o">*</span><span class="n">st</span> <span class="o">!=</span> <span class="n">LEFT_PAREN</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*++</span><span class="n">st</span> <span class="o">=</span> <span class="n">streak</span><span class="p">;</span> <span class="cm">/* Tricky bits: increment first, then dereference */</span>
                <span class="n">streak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">*++</span><span class="n">st</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">streak</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
            <span class="n">st</span><span class="o">--</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">st</span> <span class="o">&gt;=</span> <span class="n">st_base</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">st</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">streak</span> <span class="o">+=</span> <span class="o">*</span><span class="n">st</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* Tricky bits: dereference first, then decrement */</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Same as before: if there was an ongoing streak, take it into account */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">streak</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*++</span><span class="n">st</span> <span class="o">=</span> <span class="n">streak</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* The below code belongs to 'findLongestStreak' function, but using the
       new stack implementation. It also has some tricky bits */</span>
    <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* This is the final size of the stack, not the allocated one. We are
       counting the number of elements that are pushed in the stack, then
       calculating the end pointer for the loop */</span>
    <span class="kt">int</span> <span class="n">st_size</span> <span class="o">=</span> <span class="n">st</span><span class="o">-</span><span class="n">st_base</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">st_end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stbuf</span><span class="p">[</span><span class="n">st_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">st_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">edits</span> <span class="o">=</span> <span class="n">K</span><span class="p">;</span>

        <span class="cm">/* Just to make things clear, we use stbuf directly here
           to avoid grabbing the address for 'i+1' below if it is
           not needed. This is basically checking the 'i-1' position,
           because 'st' actually starts at stbuf[1]. If the previous
           position is a matched parenthesis we can skip as the previous
           sliding window should have already taken it into account. This
           is true since finding a valid matched parenthesis sequence at 'i'
           when there is another matched parenthesis sequence at 'i-1' should
           concatenate both values, as we are looking for the longest streak */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Initialize 'st' to start applying the sliding window */</span>
        <span class="n">st</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stbuf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

        <span class="cm">/* Same loop as in the original function but using our new stack implementation */</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">prevBracket</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">st</span><span class="o">!=</span><span class="n">st_end</span><span class="p">;</span> <span class="o">++</span><span class="n">st</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Position contains a matched parenthesis count (in negative),
               make it positive and add it to the current length */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">st</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">length</span> <span class="o">+=</span> <span class="o">-*</span><span class="n">st</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/* Ops, we found an unmatched parenthesis but we are out of edits, so
               break the loop and analyse the result */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* Lucky us! We still have edits left. In this case we found
               the same bracket twice, either '((' or '))' so we only need
               1 edit to fix it */</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">st</span> <span class="o">==</span> <span class="n">prevBracket</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">length</span> <span class="o">+=</span><span class="mi">2</span><span class="p">;</span>                <span class="cm">/* By editing one parenthesis we have
                                              2 more matched parenthesis */</span>
                <span class="n">edits</span><span class="o">--</span><span class="p">;</span>
                <span class="n">prevBracket</span> <span class="o">=</span> <span class="n">MATCH_PAREN</span><span class="p">;</span> <span class="cm">/* And remember we've matched it, so
                                              we don't try to match it again */</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prevBracket</span> <span class="o">==</span> <span class="n">RIGHT_PAREN</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">st</span> <span class="o">==</span> <span class="n">LEFT_PAREN</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* In this case we found two different unmatched parenthesis,
                   so ')(', we need 2 edits to match them, if we don't have that
                   many we are done with this window */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">edits</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="cm">/* Otherwise same case as in the 'if' part,
                   except we subtract 2 edits */</span>
                <span class="n">length</span> <span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
                <span class="n">edits</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">prevBracket</span> <span class="o">=</span> <span class="n">MATCH_PAREN</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* For the case when we don't have a previous parenthesis,
                   so only the first time we find an unmatched parenthesis
                   in a sliding window */</span>
                <span class="n">prevBracket</span> <span class="o">=</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Analyse the length and see if it is a maximum */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">maxLength</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">maxLength</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* If we've reached the last position no point
           on continuing processing */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">st_end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">maxLength</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Well! Now it is! Yeah! Hooray!!! We’ve optimized the brains out of that glitch!</p>

<blockquote>
  <p>For real??</p>
</blockquote>

<p>Ha! Nop….</p>

<blockquote>
  <p>Nop??</p>
</blockquote>

<p>NOP<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p>According to Codility, we still get a Silver award. Whaaaaat!?<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p>

<h1 id="about-pragmatism">About pragmatism</h1>

<p>And here we are, my dear readers. Such a long way and still we are not home. We aimed to be gods and reality has
crushed our very dreams of fame and wonder. Long ago forgotten is our pride and the upcoming scent of roses…..</p>

<blockquote>
  <p>Cut the shit, man!!</p>
</blockquote>

<p>Yeah, sorry. Just got lost in my own verbiage. My apologies.</p>

<p>You know what? It was really NOT enough. So I had to use the power of the O! More specifically the <em>-O3</em> option that
comes with the GCC compiler. This is the thing. In Codility, when you choose a language for the challenge, you can
see at the bottom the compiler used to compile your code. In my case for C/C++ it is GCC 4.8.3 if I recall correctly.
So I figured I could use some compiler specifics. The question was, of course, how to pass this flag to the compiler
when I actually didn’t have access to the Makefile or compiling script.</p>

<blockquote>
  <p>Pragmatism!</p>
</blockquote>

<p>Indeed! Did you know there is a <em>#pragma</em> directive that allows you to request certain level of optimization in GCC?
Me neither. Here it follows the life saving line:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma GCC optimize ("O3")
</span></code></pre></div></div>

<p>Now we got the Gold, baby!</p>

<p>Hope you’ve enjoyed the article. I must confess it’s taken more time for me to write the article than to write the
code! But I found the experience a nice learning one, and I thought I should share it.</p>

<p>You can always browse through my Codility repo for the Titanium challenge <a href="http://github.com/robercano/codility/tree/master/titanium">here</a>. There are several snapshots
that may reflect what I’ve explained here. You can also browse any of my other projects.</p>

<p>Keep up the good work!</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Cosmic rays can also influence your results! Beware! <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Quick answer: the first function, although for certain cases with longer number of swaps, the second is also taking some time. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Sorry, no Gollum joke here! <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>NO Pun intended…. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Whaaaaat!? <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


				<!-- Show comments -->
				
					<div id="disqus_thread"></div><!-- /#disqus_thread -->
					
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'robertocano'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

				
		  	</div><!-- /.entry-content -->
		</div><!-- /.entry-wrapper -->

		<!-- Pagination -->
    	<nav class="pagination" role="navigation">
      		
        		<a href="http://www.robertocano.es/en/golden-titanium-part1/" class="btn" title="Golden titanium alchemy - Algorithm (1/2)">Previous</a>
      		
      		
        		<a href="http://www.robertocano.es/en/improbability-engine/" class="btn" title="Mastering the improbability engine">Next</a>
      		
    	</nav><!-- /.pagination -->
	</article>
</div><!-- /#main -->

<!-- Page footer -->
<div class="footer-wrapper">
	<footer role="contentinfo" class="entry-wrapper">
		<span>
			&copy; 2021 Roberto Cano. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="http://mademistakes.com/so-simple/" rel="nofollow">So Simple Theme</a>.
		</span>
		<div class="social-icons">
			
				<a href="http://twitter.com/robersoca" title="Roberto Cano on Twitter" target="_blank"><i class="fa fa-twitter-square fa-2x"></i></a>
			
			
			
			
				<a href="http://linkedin.com/in/robertocano" title="Roberto Cano on LinkedIn" target="_blank"><i class="fa fa-linkedin-square fa-2x"></i></a>
			
			
			
			
			
				<a href="http://github.com/robercano" title="Roberto Cano on Github" target="_blank"><i class="fa fa-github-square fa-2x"></i></a>
			
			
			
			<a href="http://www.robertocano.es/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss-square fa-2x"></i></a>
		</div><!-- /.social-icons -->
	</footer>
</div><!-- /.footer-wrapper -->

<script type="text/javascript">
  var BASE_URL = 'http://www.robertocano.es';
</script>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://www.robertocano.es/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://www.robertocano.es/assets/js/scripts.min.js"></script>




</body>
</html>
